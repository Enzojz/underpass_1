local func = require "entry/func"
local coor = require "entry/coor"
local pipe = require "entry/pipe"
local general = require "entry/general"

local ma = math
local abs = ma.abs
local ceil = ma.ceil
local floor = ma.floor
local pi = ma.pi
local atan = ma.atan
local pow = ma.pow
local cos = ma.cos
local sin = ma.sin
local min = ma.min
local e = ma.exp(1)
local log = ma.log
local log10 = log(10)
local unpack = table.unpack

local widthList = {2, 3, 4, 5, 6}

function data()
    local constructionTemplates =
        {
            {
                constructionType = "STREET_CONSTRUCTION",
                type = "DYNAMIC",
                availability = {
                    yearFrom = 0,
                    yearTo = 0
                },
                description = {
                    name = _("Underpass Entry"),
                    description = _("An underpass entry"),
                    icon = "ui/construction/street/underpass_entry.tga"
                },
                data = {
                    params = {}
                },
            }
        }
    
    local createTemplateFn = function(params)
        local result = {
            [1] = "street/underpass_entry.module",
        }
        
        return result
    end
    
    local upgradeFn = function(params)
        end
    
    local updateFn = function(params)
        local result = {}
        local width = widthList[(params.width or 1) + 1]
        local dz = 0
        
        local baseConn = {
            coor.xyz(-3.5 - width * 0.5, 5.2085, -3.9 + dz),
            coor.xyz(3.5 + width * 0.5, 5.2085, -3.9 + dz)
        }
        
        result.modules = params.modules
        result.slots = func.mapi(params.modules, function(e, i)
            return {
                id = i,
                transf = e.transf or coor.I(),
                type = "entry",
                spacing = {0, 0, 0, 0}
            }
        end)
        
        if (params.modules and #params.modules > 1) then
            local trans = pipe.new * params.modules * pipe.map(pipe.select("transf")) * pipe.filter(pipe.noop())
            if (#trans > 1) then
                local allConnectors = trans
                    * pipe.mapi(function(t, i)
                        return {i = i, connectors = func.map(baseConn, function(c) return c .. t end)}
                    end)
                
                local entryConn = allConnectors
                    * pipe.map(function(co) return allConnectors
                        * pipe.filter(function(c) return c.i > co.i end)
                        * pipe.map(function(target)
                            return {
                                {
                                    conn = general.unitLane(co.connectors[1], target.connectors[1]),
                                    distance = (co.connectors[1] - target.connectors[1]):length(),
                                    info = {{co.i, 1}, {target.i, 1}}
                                },
                                {
                                    conn = general.unitLane(co.connectors[1], target.connectors[2]),
                                    distance = (co.connectors[1] - target.connectors[2]):length(),
                                    info = {{co.i, 1}, {target.i, 2}}
                                },
                                {
                                    conn = general.unitLane(co.connectors[2], target.connectors[1]),
                                    distance = (co.connectors[2] - target.connectors[1]):length(),
                                    info = {{co.i, 2}, {target.i, 1}}
                                },
                                {
                                    conn = general.unitLane(co.connectors[2], target.connectors[2]),
                                    distance = (co.connectors[2] - target.connectors[2]):length(),
                                    info = {{co.i, 2}, {target.i, 2}}
                                }
                            }
                        end)
                        * pipe.map(pipe.min(function(l, r) return l.distance < r.distance end))
                    end
                    )
                    * pipe.flatten()
                
                result.entrySide = entryConn
                    * pipe.map(pipe.select("info"))
                    * pipe.flatten()
                    * pipe.fold({}, function(r, c)
                        return func.with(r,
                            {
                                [c[1]] = func.with(r[c[1]] or {false, false}, {[c[2]] = true})
                            })
                    end)
                result.models = entryConn * pipe.map(pipe.select("conn"))
            else
                result.models = {}
            end
        else
            result.models = {}
        end
        
        result.colliders = {}
        result.terrainAlignmentLists = {}
        result.groundFaces = {}
        result.terminalGroups = {}
        result.stations = {}
        result.dependentSlots = {}
        result.edgeLists = {}
        result.slotConfig = {}
        
        result.occupied = {{}, {}, {}, {}}
        result.cost = 0
        result.terminateConstructionHook = nil
        return result
    end
    
    return {
        type = "STREET_CONSTRUCTION",
        description = {
            name = _("Underpass Entry"),
            description = _("An underpass entry")
        },
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        order = 1000,
        constructionTemplates = constructionTemplates,
        createTemplateFn = createTemplateFn,
        params = {
            {
                key = "style",
                name = _("Style"),
                values = {_("Glass"), _("Normal"), _("Concrete")},
                defaultIndex = 0
            },
            {
                key = "wall",
                name = _("Wall"),
                values = {_("Tiles 1"), _("Tiles 2")},
                defaultIndex = 0
            },
            {
                key = "floor",
                name = _("Floor Style"),
                values = {_("Marble 1"), _("Honeycomb"), _("Marble 2"), _("Concrete"), _("Asphalt")},
                defaultIndex = 0
            },
            {
                key = "width",
                name = _("Width (m)"),
                values = func.map(widthList, tostring),
                defaultIndex = 1
            },
        },
        upgradeFn = upgradeFn,
        updateFn = updateFn
    }
end
